// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "Helpers/Noise.compute"

struct testStruct
{
	uint3 indices;
	uint index;
};

uint width;
uint height;
float3 offset;

float noiseScale;
float pointScale;

RWStructuredBuffer<float4> noiseBuffer;

uint indexFromCoord(uint3 id)
{
	//return z * width * height + y * width + x;
	return id.x + (id.y * width) + (id.z * width * height);
}

[numthreads(8, 8, 8)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	// Get the correct index
	const uint index = indexFromCoord(id);
	
	// Get the noise point corresponding to this index
	const float4 noisePoint = noiseBuffer[index];

	// Calculate the noise and set it to the fourth component
	// Assign this modified noise to the buffer

	const float3 p = float3(noisePoint.xyz) + offset;

	float noise;

	// Flatten towards a surface level
	noise = p.y + snoise(float3(p.x, 0, p.z));
	
	const int iterations = 5;
	
	// Add details
	float hH = -p.y + snoise(float3(p.x, 0, p.z) / 5);
	for (int i = 2; i < iterations; ++i)
	{
		noise += snoise(float3(p.x, 0, p.y) / (i * 5)) * i / iterations;
	}

	float pH = snoise(p / 10);
	for (int i = 2; i < iterations; ++i)
	{
		pH -= snoise(p / (i)) * i / iterations;
	}
	noise = -p.y + (pH / 4 + hH) * 10;

	float3 mP = float3(p.x + 4345.35, 0, p.z + -325.2);
	float mm = snoise(mP / 50);
	noise = -p.y + (pH / 2 + hH) * 1 * mm;
	
	noiseBuffer[index][3] = (noise);
}
